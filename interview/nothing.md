面试官好, 我叫刘帆, 来自山东大学现大三, 从大一下学期开始对前端感兴趣, 先后加入学校的 web 实验室与学生在线的 web 组, 最初通过看红宝书和阮一峰的 es6 教程以及慕课网和 freecodecamp 等网站系统学习前端, 然后慢慢通过看博客文章和编写一些 demo 学习, 现在拥有了能完成小项目的能力, 希望能够加入公司完成一些能让更多人能使用的应用, 继续扎根在前端这条路上不断学习前进

最近遇见的 bug, 就说最近的印象深的, 因为平时有存储图片在手机上, 但是传图片到电脑上比较麻烦, 所以用 nodejs 写了一个上传的服务, 然后电脑开了热点, 但是传的时候发现每次都是选择超过 6 张左右就会卡住, 检查代码怎样都没问题, 然后 stackoverflow 上了解到浏览器对同一域名最大连接数是 6, 后面就在前端代码里维护了一个上传队列, 用 promise 来确保上传不堵塞还有就是写一个 smms 图库的图片上传, 因为他们的 api 刚刚更新过, 所以网上之前搜索的上传组件都没法用, 我就自己写一个, 结果发现怎么都没法传, 返回的参数永远提示我上传错误, 翻了他们 api 翻了半天, 最后想到去 github 上找找会不会有, 然后搜到一个最近的代码, 套用上去终于上传成功了, 原来是用 formData 上传的时候 content-type 的 multiple 后面没相应的 boundary, 应该把 boundary 带上, 与上传堵塞相关的还有文件下载的堵塞, 因为 nodejs 的线程由 libuv 库主控, 这个库默认最大线程数是 4, 所以下载数同时一多, 与文件系统建立连接所使用线程超过就会堵塞, 后面用一个信号量, 限定大小是 3, 每一次下载消耗一个, 下载完成或者失败就加一, 后面下载基本就没问题了

有没有什么能增加实际上线项目经验的方法, 比如说多接外包?找合作团队?

求稳一点的话, 请问我有什么缺点, 接下来该往哪方面学习, 还可以问问前端有哪些不错的发展方向

浏览器/Node 的事件循环

> 在 js 单线程的基础上实现无阻塞的关键特性, js 执行有执行栈和事件队列, 如果遇到异步的任务, 会挂起等到返回结果后放入消息队列中, 然后循环就在这一步, 当栈中的任务执行完毕后, 就会去查看队列中的任务, 如果有就将其放入执行栈中, 重复这一步, 当然现在有了 promise, 又细分为微任务队列和宏任务异步队列, 循环时先检查微任务队列, 然后检查宏任务队列, node 中的事件循环表现与浏览器大致相同, 但是 node 事件循环依靠的 libuv 引擎, 仅用 v8 来解释 js 代码

CSRF 的原理和防御手段

> csrf, cross site request forgery, 举个例子来说, 刚刚访问了 A 网站, 然后访问了 B 网站, B 网站有 image 或者 form 请求指向了 A, 注意 cookie 的 samesite strict 策略, 防御方法关键是让攻击者提供其提供不了的信息, 比如验证码, token 一个存在于 session 的随机值, 还有请求的 refer

XSS 原理和防御手段

> 通过网页面注入 script 标签来获取用户信息, 可以通过输入过滤, 纯前端渲染, 使用 textcontent 等 api 来防御

跨域

> 跨域, 是因为同源策略限制, 有三个特性, 无法获得不同域的 cookie, 无法发送不同域的 ajax, 无法获得 dom, 但是日常开发的时候又需要这些, 比如访问不同网站的资源, 为了解决 cookie 类, 如果仅是二级域名等不相同, 可以用`document.domain`, 这个也适用于获取 dom, 发送 ajax, 可以用 jsonp 和 cors, 如果完全不同源的窗口之间, 可以用 postmessage

浏览器的渲染机制

> 浏览器的渲染需要生成两棵树, dom 和 cssom 然后合并为渲染树来安排节点位置, 但是浏览器的渲染引擎同时又会受到 js 引擎的影响, 因为 js 可能会操作 dom, 也可能需要读取此时的 css style 属性, 所以具体的渲染应该是, 下载文档开始首先预解析收到的数据然后根据 content-type 确定编码, 如果 meta 中指定了就用 meta 中的, 然后开始并行下载资源, 如果是 http1 的话会有域名并发限制问题, 如果解析到 script 标签, 就暂停, 等待此时的 js 下载完成, 并且执行完, 如果在解析到 script 标签之前还有 css 标签, 此时停止 dom 解析和 js 引擎, 先等 css 下载完毕并且生成 cssom, 页面最先显示的时间应该是 cssom 最开始生成的时间, 所以为了加快首屏渲染应该内嵌关键 css 样式

首屏与白屏

> 首屏指的是视窗内的内容初步加载完成, 白屏是指的浏览器开始显示内容的时候, 加快加载时间实际上就是遵照浏览器的渲染机制来加载, 一个是资源, 第二个是渲染, 资源可以用 cdn, 域名分片, 合并文件, 启用缓存, 当然也可以使用 http2, 渲染可以优先加载关键 css, js 放在最后, 使用 async, defer 来加载并不会操作 dom 的 js 文件, 当然还有安慰剂骨架屏, 另外对于单页应用还有服务端同构 ssr, 这样可以利用服务端计算力的优势来先加载部分 vdom, 还可以省去 ajax 的时间

async defer 指的是

> 可以作用在 script 标签上的属性, 对内联 script 无效, defer 不阻塞浏览器解析 html, 等解析完成后执行, async 则相当于用 js 动态添加 script, 加载完便执行

什么是 http2

> http2 的目的是解决浏览器使用多个 tcp 连接到服务器, 目标是只使用一个 tcp 连接来传输所有资源文件, 它采取的措施是, 每个文件算一个流, 每个流由不少帧构成, 帧可以交错发往客户端, 客户端通过帧号来判断属于哪个文件流, 这就是最主要的多路复用, 此外还有 server push 也就是服务器主动往客户端推送文件, 当然浏览器可以选择接收还是不接收, 另外还解决了 http1 时候请求头过大的问题, 手段是将部分 cookie 缓存并且压缩 header, 当然 http2 也有缺点, 就是 tcp 连接的丢包, 如果丢包会造成后面要发的包缓存再发, 会拖慢速度

tcp 三次握手, 四次挥手

> 三次握手的目的是确认互相的收发能力, 请求时, 客户端发送带有 SYN 的请求过去, 然后服务端收到后返回一个带有 SYN 的响应, 这两步就确认了客户端的发的能力和服务端的收发的能力, 然后客户端再发送一个请求, 此时可以携带数据, 这一步就确认了客户端的接收能力, 四次挥手目的是让连接断开时要发送的数据都发送完, 并且双方相关进程资源释放, 某一方放松断开的 FIN 的请求过去, 然后另一方返回一个响应, 再发送带有 FIN 的响应, 这三步完成了将应该发送的资源都发送完毕, 然后之前要求断开的再返回一个 ACK 确认, 如果没有收到这个确认会一直发送 FIN 的响应直到到达等待时间上线, 这里就是为了双方资源都释放

https

> https 保障的是通信双方的信件未被中间人纂改, 实现的方法是加密, 也就是非对称加密方法, 有一个公钥和私钥, 客户端请求时, 服务端发送一个数字证书过来, 客户端根据数字证书中的公钥加密一个随机值, 然后发送往服务端, 服务端收到后用自己的私钥解开后获得了这个随机值, 然后双方就可以用这个进行对称加密, 也就是双方都知道加密和解密的方法

TCP 与 UDP 区别

> TCP 面向连接, 可靠, 能控制发包速度和自动重发, 但是只能一对一, UDP 无连接, 尽可能交付, 但是可以多对多, 在应用上, TCP 可以传文件, UDP 可以用于直播, DNS 查询等

http 缓存

> 分为强缓存和协商缓存, 强缓存生效不用发送请求直接使用, 协商缓存需要询问服务端, 如果返回 304 则使用缓存, 有四个 http 字段来控制, 强缓存, expires, 控制 max-age 最大缓存时间, cache-control, 可以控制代理的缓存, 协商缓存, last-modified, 最后一次修改的时间, 但是如果文件在一秒内多次修改或者分布式的服务器就没法掌控, 所以又有 etag, 资源的哈希值, 哈希值是一种能将文件运算至 128 位的算法, 这个值几乎独一无二, 可以用来唯一表示这个文件, 请求这边也有两个相应的字段, if modified since 和 if-none-match, 值就是之前的值, 用啦询问服务器文件是否可以使用缓存

浏览器缓存

> cookie, 用来鉴权的一种手段, 配合 session 使用, 可以用来存储用户信息, 但是 cookie 大小一般会被限制, 所以又有 localstorage 和 sessionstorage, 这两个东西的区别是一个是会话结束也就是关闭标签页就消失, 一个如果不被清除可以一直使用

鉴权手段

> 共四种, http basic authentication, 请求服务器会返回 401, 然后弹出验证框, cookie session, cookie 存储 sessionid, session 存储用户信息, token, token 加密存储用户信息, OAuth, 用于授予访问网站部分内容的权利

http 状态码

> 五种, 100 左右意味着服务器成功收到信息但还需要客户端处理, 200 意味着服务器收到正确信息并且已经处理, 300 意味着客户端需要重新定位资源地址, 400 意味着客户端的请求有问题, 500 意味着服务器有问题

vue

> vue 是一个基于 MVVM 的框架, 能够双向绑定数据实现 MVVM 中的 viewmodel 部分, 这个实现是通过 Object.defineProperty 中设置属性的 getter 和 setter 达成的, 在 vue3 中改用 es6 中的 proxy 来实现, vue 的架构是由四个部分组成, 基于观察者模式, observer 监听数据变动, 然后通知 dep, 然后 dep 调用 notify 方法挨个通知 watcher, watcher 调用自身的 update 方法更新视图, 在初始化的时候用 compile 来解释模板中的 v 指令, 同时生成 watcher, vue 的 dom 操作采用虚拟 dom 的形式, 用对象来代表节点以此生成树, 每次变动都检查这棵树并将变动应用上去, 然后根据变动后的树和之前的树对比形成 dom 节点, 好处是能避免频繁操作 dom, 但是没法达到直接操作 dom 的性能上限

this

> this 的指向有四个模式, 默认, 直接调用的时候指向 window, 隐式, 使用对象调用的时候指向对象, 当然这个过程中可能会发生隐式丢失的情况, 显式, 使用 bind, apply, call 来调用, 此时指向他们传入的第一个参数, 最后就是 new 操作, 指向生成的新对象

bind, apply, call

> bind 返回一个指定好 this 的函数, apply 和 call 指定调用时的 this, 区别是参数, apply 仅接受两个参数, 一个是 thisArg, 一个是类数组, call 则是接受一系列的参数

闭包

> 闭包指的是在函数中声明的另一个函数, 基于作用域可以调用外部函数的变量, 即便外部函数执行完毕也能使用其中的变量, 可以用它来调用私有属性, 防止污染全局环境, 但是如果不释放会消耗内存的使用

继承

> js 中的继承使用的是原型链继承, 主要涉及的属性是 proto 和 prototype, 对象的 proto 指向其构造函数的 prototype, 构造函数的继承上, 主要有三种, 原型继承, 将构造函数的 prototype 指向父函数 new 出来的对象, 构造继承, 在构造函数内将 this 放入父构造函数中执行, 组合继承, 结合原型继承和构造继承, 他们分别的缺点是第一种无法传参使用父构造函数的实例属性, 并且原型链上的引用属性易被更改, 组合继承共享一个引用对象, 构造继承无法使用原型链上的方法, 所以有寄生组合继承, 使用 Object.create 来生成 父函数的原型链

const, let

> let, 暂时性死区, 无法在声明前使用变量, 在 for 循环中有块级作用域, 不允许重复声明, const 不允许声明的变量更改

html 语义化

> 使用 h5 中新出的语义化标签, 标签名字即可看出其作用, 好处是搜索引擎友好, 对相关辅助设备解析有帮助, 能够在没有加载 css 的情况下显示一定的文档结构

单页应用和多页应用

> 单页应用指的是只有一张 web 页面的应用, 利用哈希或者 history 来控制链接的跳转来更新内容, 公共资源仅需要加载一次, 优点是前后端完全分离, 用户体验不错, 缺点是 seo 因为搜索引擎难以等待利用 ajax 来更新内容

双飞燕布局

> float, inline-block, flex

前端性能优化

> 其实这个类似于首屏优化, 同样从是资源加载和渲染执行, 资源加载主要是两点, 减少文件大小和加速资源下载, 可以用 cdn, 域名分片, 合并文件, 启用缓存, 当然也可以使用 http2, 还有 gzip 压缩, 渲染执行上, 又分为渲染和执行, js 放尾部, css 放首部, 动态加载 script, 事件防抖节流, DOM 操作使用 fragment 等

从输入 url 到网页呈现的过程

> 解析 HSTS 列表, DNS 解析注意 DNS 会有缓存, 然后 TCP 握手, 如果是 https 则先发送数字证书, 建立 https 连接, 然后服务器返回文档, 浏览器解析渲染页面

回流重绘

> 回流, 当更改 css 影响到节点布局, 浏览器将会重新解析 cssom 和 dom, 然后合并为渲染树再进行渲染, 重绘, 如果仅仅只是修改了颜色, 不影响其位置, 那么只会针对这个元素重新绘制

浏览器事件模型与事件委托

> dom0 级, 触发绑定元素上的相应事件就执行 handler, 绑定方法是 onclick 等, dom2 级, 事件从顶层对象捕获阶段直到触发元素阶段后进入冒泡阶段, 但是由于早期有些浏览器不支持捕获, 所以一般用的冒泡,阻止事件冒泡捕获, e.stopPropagation, 取消默认事件, e.preventDefault, 事件委托是为了简化操作, 只在父元素上绑定事件然后根据传入的元素执行 handler, e.currentTarget 指的是当前事件所在的元素, target 指的是绑定事件 handler 的元素, dom1 级规范了下 0 级, dom3 级增加了部分事件

前端模块化

> 从时间线的发展上来说, 首先是 commonJs, 最初用于 node, 同步加载, 输出的是值的拷贝, 为了解决同步加载问题, 有 requirejs 使用的 amd, 异步加载, 但是没法按需加载, 所以又有了 seaJs 的 CMD 规范, 支持按需加载, 发展到 es6 有了综合的一个统一规范了, 就是常见的 import
